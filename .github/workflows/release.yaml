name: Release

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read  # Default to read-only; jobs override as needed

jobs:
  # Create a PR with the new versions and changelog, preparing the next release
  # Uses GitHub App token instead of GITHUB_TOKEN for PR creation to avoid
  # the "GitHub Actions is not permitted to create or approve pull requests" error.
  # This approach is more secure than enabling repository-wide PR creation permission:
  # - Token is scoped to ofsht repository only
  # - Auto-expires after 1 hour
  # - Clear audit trail via GitHub App activity log
  # - Job-level permission isolation (read-only default)
  release-plz-pr:
    name: Release PR
    runs-on: ubuntu-latest
    permissions:
      contents: read  # Minimal permission (GitHub App token handles PR creation)
    concurrency:
      group: release-plz-${{ github.ref }}
      cancel-in-progress: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Install Rust toolchain
        uses: ./.github/actions/setup-rust

      - name: Generate GitHub App token
        id: release-token
        uses: actions/create-github-app-token@7e473efe3cb98aa54f8d4bac15400b15fad77d94 # v2.2.0
        with:
          app-id: ${{ vars.OFSHT_APP_ID }}
          private-key: ${{ secrets.OFSHT_APP_PRIVATE_KEY }}
          permission-contents: write
          permission-pull-requests: write

      - name: Run release-plz (release-pr)
        uses: release-plz/action@d529f731ae3e89610ada96eda34e5c6ba3b12214 # v0.5.118
        with:
          command: release-pr
        env:
          GITHUB_TOKEN: ${{ steps.release-token.outputs.token }}

  # Release unpublished packages
  release-plz-release:
    name: Release
    runs-on: ubuntu-latest
    outputs:
      release_created: ${{ steps.release.outputs.releases_created }}
      tag_name: ${{ steps.extract_tag.outputs.tag }}
    permissions:
      contents: write
      id-token: write  # Required for OIDC token minting
    steps:
      - name: Checkout repository
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Install Rust toolchain
        uses: ./.github/actions/setup-rust

      - name: Generate GitHub App token
        id: release-token
        uses: actions/create-github-app-token@7e473efe3cb98aa54f8d4bac15400b15fad77d94 # v2.2.0
        with:
          app-id: ${{ vars.OFSHT_APP_ID }}
          private-key: ${{ secrets.OFSHT_APP_PRIVATE_KEY }}
          permission-contents: write

      - name: Authenticate with crates.io
        id: crates-io-auth
        uses: rust-lang/crates-io-auth-action@b7e9a28eded4986ec6b1fa40eeee8f8f165559ec # v1.0.3

      - name: Run release-plz (release)
        id: release
        uses: release-plz/action@d529f731ae3e89610ada96eda34e5c6ba3b12214 # v0.5.118
        with:
          command: release
        env:
          GITHUB_TOKEN: ${{ steps.release-token.outputs.token }}
          CARGO_REGISTRY_TOKEN: ${{ steps.crates-io-auth.outputs.token }}

      - name: Extract tag name
        id: extract_tag
        if: steps.release.outputs.releases_created == 'true'
        run: |
          # Extract tag from release-plz output
          tag=$(echo '${{ steps.release.outputs.releases }}' | jq -r '.[0].tag')
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "Created release tag: $tag"

  # Build binaries for multiple platforms (only when release is created)
  build-binaries:
    name: Build ${{ matrix.target }}
    needs: release-plz-release
    if: needs.release-plz-release.outputs.release_created == 'true'
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux GNU
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            cross: false
            strip: strip
            archive_suffix: tar.gz

          # Linux MUSL (static binary)
          - target: x86_64-unknown-linux-musl
            os: ubuntu-latest
            cross: true
            strip: strip
            archive_suffix: tar.gz

          # macOS x86_64
          - target: x86_64-apple-darwin
            os: macos-latest
            cross: false
            strip: strip
            archive_suffix: tar.gz

          # macOS ARM64 (Apple Silicon)
          - target: aarch64-apple-darwin
            os: macos-latest
            cross: true
            strip: strip
            archive_suffix: tar.gz

    steps:
      - name: Checkout repository
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: ./.github/actions/setup-rust
        with:
          targets: ${{ matrix.target }}

      - name: Install cross-compilation tools
        if: matrix.cross
        run: |
          if [ "${{ matrix.target }}" = "x86_64-unknown-linux-musl" ]; then
            sudo apt-get update
            sudo apt-get install -y musl-tools
          fi

      - name: Cache cargo registry
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        continue-on-error: true
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo index
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        continue-on-error: true
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo build
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        continue-on-error: true
        with:
          path: target
          key: ${{ runner.os }}-cargo-build-target-${{ matrix.target }}-${{ hashFiles('**/Cargo.lock') }}

      - name: Build release binary
        run: cargo build --release --target ${{ matrix.target }}

      - name: Strip binary
        run: ${{ matrix.strip }} target/${{ matrix.target }}/release/ofsht

      # IMPORTANT: Asset naming format is critical for mise ubi backend compatibility
      # Format: ofsht-${target}.tar.gz containing single ofsht binary at root
      # Changes to naming or archive structure will break mise installations
      # See CONTRIBUTING.md "mise ubi Distribution" section for details
      - name: Create archive
        run: |
          cd target/${{ matrix.target }}/release
          tar czf ofsht-${{ matrix.target }}.${{ matrix.archive_suffix }} ofsht
          mv ofsht-${{ matrix.target }}.${{ matrix.archive_suffix }} ${{ github.workspace }}/

      - name: Upload artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
        with:
          name: ofsht-${{ matrix.target }}
          path: ofsht-${{ matrix.target }}.${{ matrix.archive_suffix }}
          if-no-files-found: error

  # Attach binaries to GitHub Release
  attach-assets:
    name: Attach Release Assets
    needs: [release-plz-release, build-binaries]
    if: needs.release-plz-release.outputs.release_created == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to upload assets and publish release
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093 # v4.3.0
        with:
          path: artifacts

      - name: Prepare release assets
        run: |
          mkdir -p release-assets
          find artifacts -type f -name "*.tar.gz" -exec mv {} release-assets/ \;
          ls -lh release-assets/

      - name: Upload release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          tag="${{ needs.release-plz-release.outputs.tag_name }}"

          # Upload all assets to the draft release
          gh release upload "$tag" release-assets/* \
            --repo "$GITHUB_REPOSITORY" \
            --clobber

          echo "Uploaded assets to release $tag"

      - name: Verify release assets
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          tag="${{ needs.release-plz-release.outputs.tag_name }}"

          # Check that exactly 4 assets were uploaded
          asset_count=$(gh release view "$tag" --repo "$GITHUB_REPOSITORY" --json assets --jq '.assets | length')

          if [ "$asset_count" -ne 4 ]; then
            echo "Error: Expected 4 assets, found $asset_count"
            gh release view "$tag" --repo "$GITHUB_REPOSITORY" --json assets --jq '.assets[].name'
            exit 1
          fi

          echo "Verified: $asset_count assets uploaded successfully"

      - name: Publish release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          tag="${{ needs.release-plz-release.outputs.tag_name }}"

          # Publish the draft release
          gh release edit "$tag" --repo "$GITHUB_REPOSITORY" --draft=false --latest

          echo "Published release $tag"

  # Update Homebrew tap
  # This job uses a GitHub App for authentication instead of a PAT for improved security:
  # - Repository-scoped permissions (only homebrew-tap)
  # - Automatic token rotation (per workflow run)
  # - 1-hour token expiration
  # - Clear audit trail via GitHub App activity logs
  #
  # Required setup:
  # - GitHub App with permissions: actions (write/read), contents (read)
  # - App installed on both ofsht and homebrew-tap repositories
  # - OFSHT_APP_ID variable and OFSHT_APP_PRIVATE_KEY secret configured
  update-homebrew-tap:
    name: Update Homebrew Tap
    needs: [release-plz-release, attach-assets]
    if: needs.release-plz-release.outputs.release_created == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read  # Minimal permissions (GitHub App token handles homebrew-tap access)
    steps:
      # Generate a short-lived token (1-hour expiration) scoped to homebrew-tap repository
      # SHA-pinned to v2.2.0 for supply chain security
      - name: Generate GitHub App token
        id: generate-token
        uses: actions/create-github-app-token@7e473efe3cb98aa54f8d4bac15400b15fad77d94 # v2.2.0
        with:
          app-id: ${{ vars.OFSHT_APP_ID }}
          private-key: ${{ secrets.OFSHT_APP_PRIVATE_KEY }}
          owner: wadackel
          repositories: homebrew-tap

      - name: Trigger and monitor tap update workflow
        env:
          GH_TOKEN: ${{ steps.generate-token.outputs.token }}
        run: |
          set -euo pipefail

          TAG="${{ needs.release-plz-release.outputs.tag_name }}"
          REPO="wadackel/homebrew-tap"
          # Record current time for filtering workflow runs
          DISPATCH_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          echo "Triggering Homebrew tap update for version $TAG..."

          # Trigger workflow
          gh workflow run update.yaml \
            --repo "$REPO" \
            --field formula=ofsht \
            --field version="$TAG" \
            --field repository=wadackel/ofsht \
            || { echo "::error::Failed to trigger workflow"; exit 1; }

          echo "Workflow dispatch sent successfully"

          # Wait for the workflow run to appear and retry (gh workflow run doesn't return run ID)
          # GitHub API may take time to propagate the new workflow run
          MAX_RETRIES=6  # 60 seconds total
          RETRY_COUNT=0
          RUN_ID=""

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            RUN_ID=$(gh run list \
              --repo "$REPO" \
              --workflow update.yaml \
              --created ">$DISPATCH_TIME" \
              --limit 1 \
              --json databaseId \
              --jq '.[0].databaseId // empty')

            if [ -n "$RUN_ID" ]; then
              break
            fi

            echo "Waiting for workflow run to appear... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
            sleep 10
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done

          if [ -z "$RUN_ID" ]; then
            echo "::warning::Could not find workflow run, skipping verification"
            echo "Check manually at: https://github.com/$REPO/actions/workflows/update.yaml"
            exit 0
          fi

          echo "Workflow triggered with run ID: $RUN_ID"
          echo "Monitoring workflow at: https://github.com/$REPO/actions/runs/$RUN_ID"

          # Wait a few seconds for the workflow to start
          sleep 5

          # Monitor workflow completion (with timeout)
          TIMEOUT=300  # 5 minutes
          ELAPSED=0
          while [ $ELAPSED -lt $TIMEOUT ]; do
            STATUS=$(gh run view "$RUN_ID" --repo "$REPO" --json status --jq '.status')
            CONCLUSION=$(gh run view "$RUN_ID" --repo "$REPO" --json conclusion --jq '.conclusion' || echo "")

            echo "[$ELAPSED s] Workflow status: $STATUS, conclusion: $CONCLUSION"

            if [ "$STATUS" = "completed" ]; then
              if [ "$CONCLUSION" = "success" ]; then
                echo "âœ“ Homebrew tap update completed successfully"
                echo "Check PR at: https://github.com/$REPO/pulls"
                exit 0
              else
                echo "::warning::Homebrew tap update failed with conclusion: $CONCLUSION"
                echo "View logs at: https://github.com/$REPO/actions/runs/$RUN_ID"
                echo "Note: Release was published successfully despite tap update failure"
                exit 0
              fi
            fi

            sleep 10
            ELAPSED=$((ELAPSED + 10))
          done

          echo "::warning::Workflow monitoring timed out after ${TIMEOUT}s"
          echo "Workflow may still be running: https://github.com/$REPO/actions/runs/$RUN_ID"
          exit 0
